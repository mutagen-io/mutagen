package core

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"runtime"
	"strings"

	"golang.org/x/text/unicode/norm"

	"github.com/mutagen-io/mutagen/pkg/filesystem"
	"github.com/mutagen-io/mutagen/pkg/stream"
	"github.com/mutagen-io/mutagen/pkg/synchronization/core/fastpath"
)

const (
	// crossDeviceRenameTemporaryNamePrefix is the file name prefix to use for
	// intermediate temporary files used in cross-device renames.
	crossDeviceRenameTemporaryNamePrefix = filesystem.TemporaryNamePrefix + "cross-device-rename"

	// transitionCopyBufferSize specifies the size of the internal buffer that a
	// transitioner uses to copy file data (e.g. when performing cross-device
	// renames).
	// TODO: Figure out if we should set this on a per-machine basis. This value
	// is taken from Go's io.Copy method, which defaults to allocating a 32k
	// buffer if none is provided.
	transitionCopyBufferSize = 32 * 1024

	// transitionCopyPreemptionInterval specifies the interval between
	// preemption checks when performing file copies. This, multiplied by
	// transitionCopyBufferSize, determines the maximum number of bytes that can
	// be written to a destination file between preemption checks and thus
	// controls the maximum preemption latency.
	transitionCopyPreemptionInterval = 1024
)

var (
	// errTransitionCancelled indicates that the transition was cancelled.
	errTransitionCancelled = errors.New("transition cancelled")
)

// Provider defines the interface that higher-level logic can use to provide
// files to transition algorithms.
type Provider interface {
	// Provide returns a filesystem path to a file containing the contents
	// with the expected path and content digest. The provider does not need to
	// ensure that the file exists.
	Provide(path string, digest []byte) (string, error)
}

// transitioner provides the recursive implementation of transitioning.
type transitioner struct {
	// cancelled is the cancellation channel from the transition context.
	cancelled <-chan struct{}
	// root is the path to the synchronization root.
	root string
	// cache is the file digest cache generated by scan.
	cache *Cache
	// symbolicLinkMode is the symbolic link mode being used.
	symbolicLinkMode SymbolicLinkMode
	// defaultFileMode is the default file permission mode to use when creating
	// and updating files. If executability information is being propagated,
	// then it will be used as a base to construct final file permissions.
	defaultFileMode filesystem.Mode
	// defaultDirectoryMode is the default directory permission mode to use when
	// creating directories.
	defaultDirectoryMode filesystem.Mode
	// defaultOwnership is the default ownership specification to use in
	// "portable" permission propagation.
	defaultOwnership *filesystem.OwnershipSpecification
	// copyBuffer is the copy buffer used for copying files.
	copyBuffer []byte
	// recomposeUnicode indicates whether or not filenames need to be recomposed
	// due to Unicode decomposition behavior on the synchronization root
	// filesystem.
	recomposeUnicode bool
	// provider is the staged file provider.
	provider Provider
	// problems are the problems encountered during transition operations.
	problems []*Problem
	// providerMissingFiles indicates that the staged file provider returned an
	// os.IsNotExist error for at least one file that was expected to be staged.
	providerMissingFiles bool
}

// recordProblem records a new problem.
func (t *transitioner) recordProblem(path string, err error) {
	t.problems = append(t.problems, &Problem{Path: path, Error: err.Error()})
}

// nameExistsInDirectoryWithProperCase is a utility method that checks if a name
// exists within the specified directory, recomposing the names of the
// directory's contents if necessary.
func (t *transitioner) nameExistsInDirectoryWithProperCase(
	name string,
	directory *filesystem.Directory,
) (bool, error) {
	// Grab the content names in the directory.
	names, err := directory.ReadContentNames()
	if err != nil {
		return false, fmt.Errorf("unable to read directory contents: %w", err)
	}

	// Check if this path component exists in the contents. It's important
	// to note that the contents are not guaranteed to be ordered, and we
	// may need to recompose Unicode, so we can't do a binary search here.
	for _, n := range names {
		if !t.recomposeUnicode && n == name {
			return true, nil
		} else if t.recomposeUnicode && norm.NFC.String(n) == name {
			return true, nil
		}
	}

	// No match was found.
	return false, nil
}

// walkToParentAndComputeLeafName walks down to the parent directory of the
// specified path, verifying proper casing at each step, and optionally
// validating the casing of the path leaf. It returns the Directory object
// representing the parent path and the base name of the path, or an error if
// this operation fails. If provided a root (empty) path, it will open the
// parent directory of the root path and return the base name of the root path.
// If the parent directory does not exist, this method will create it if
// requested.
//
// The purpose of this function is to transform any transition operation into
// one where we have a Directory object for race-free filesystem access, the
// base name of the content within that directory which needs to be transformed,
// and (external to this function) the old and new content specifications.
//
// This method's implementation also has the side effect of enforcing case
// correctness. If verifyLeafCasing is true, then this method will additionally
// verify that the casing of the leaf name of the path matches what's on the
// filesystem.
func (t *transitioner) walkToParentAndComputeLeafName(
	path string,
	validateLeafCasing bool,
) (*filesystem.Directory, string, error) {
	// Handle the special case of a root path. In this case we open the parent
	// directory of the synchronization root and return the base name of the
	// synchronization root.
	if path == "" {
		// Split the synchronization root path into parent path and base name.
		// If the base name is empty, it means that the synchronization root
		// path represents the filesystem root (i.e. '/' on POSIX systems and
		// a drive root on Windows). If this is the case, then return an error,
		// because we need to be able to access the root's parent in order to
		// modify the root itself. In practice, this is fine, because there are
		// no transitions that we could perform on a filesystem root anyway (it
		// will always just be a directory).
		//
		// Note that we're assuming here that the path is absolute and
		// normalized (i.e. it's not something like "/component/"). This is fine
		// because we require this for synchronization root paths passed to
		// Transition.
		rootParentPath, rootName := filepath.Split(t.root)
		if rootName == "" {
			return nil, "", errors.New("root path is a filesystem root")
		}

		// Open the parent. We do allow the parent path to be a symbolic link
		// since we allow symbolic link resolution for parent components of the
		// synchronization root (just not at the synchronization root itself).
		if rootParent, _, err := filesystem.OpenDirectory(rootParentPath, true); err != nil {
			return nil, "", fmt.Errorf("unable to open synchronization root parent directory: %w", err)
		} else {
			return rootParent, rootName, nil
		}
	}

	// Split the path and extract the parent components and leaf name.
	components := strings.Split(path, "/")
	parentComponents := components[:len(components)-1]
	leafName := components[len(components)-1]

	// Open the root path. If it's not a directory, then this operation isn't
	// valid.
	parent, _, err := filesystem.OpenDirectory(t.root, false)
	if err != nil {
		return nil, "", fmt.Errorf("unable to open synchronization root: %w", err)
	}

	// Traverse through parent components, validating casing as we go and moving
	// down the directory hierarchy.
	for _, component := range parentComponents {
		// Verify that the next component exists with the proper casing.
		if found, err := t.nameExistsInDirectoryWithProperCase(component, parent); err != nil {
			parent.Close()
			return nil, "", fmt.Errorf("unable to verify parent path casing: %w", err)
		} else if !found {
			parent.Close()
			return nil, "", errors.New("parent path does not exist or has incorrect casing")
		}

		// RACE: There is technically a race condition here because the path
		// could be removed and recreated with a different case between our
		// check and the time that we open it. Unfortunately there's nothing we
		// can do about this - case insensitive filesystems simply suffer this
		// issue. The worst case fallout here is not severe. Case insensitive
		// filesystems won't allow two names which differ only in casing, so
		// technically we're still opening the "right" path, though arguably not
		// so in the context of our synchronization algorithm (which is
		// case-sensitive). Case sensitive filesystems don't suffer from any
		// issue here. In any case, the synchronization algorithm will see the
		// correct casing on the next synchronization cycle.

		// Open the next directory.
		if p, err := parent.OpenDirectory(component); err != nil {
			parent.Close()
			return nil, "", fmt.Errorf("unable to open parent component: %w", err)
		} else {
			parent.Close()
			parent = p
		}
	}

	// Once we've extracted the parent, validate the leaf name casing if
	// requested.
	if validateLeafCasing {
		if found, err := t.nameExistsInDirectoryWithProperCase(leafName, parent); err != nil {
			parent.Close()
			return nil, "", fmt.Errorf("unable to verify path leaf name casing: %w", err)
		} else if !found {
			parent.Close()
			return nil, "", errors.New("leaf name does not exist or has incorrect casing")
		}
	}

	// Success.
	return parent, leafName, nil
}

// ensureExpectedFile ensures that the file specified by name within the
// specified directory matches the specified entry.
func (t *transitioner) ensureExpectedFile(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Grab cache information for this path. If we can't find it, we treat this
	// as an immediate fail. This is a bit of a heuristic/hack, because we could
	// recompute the digest of what's on disk, but for our use case this is very
	// expensive and we SHOULD already have this information cached from the
	// last scan.
	cached, ok := t.cache.Entries[path]
	if !ok {
		return errors.New("unable to find cache information for path")
	}

	// Grab metadata for this path.
	metadata, err := parent.ReadContentMetadata(name)
	if err != nil {
		return fmt.Errorf("unable to grab file statistics: %w", err)
	}

	// Instead of comparing directly against the expected entry, compare the
	// current metadata with that in the cache. If that matches, compare the
	// cached digest with that of the entry. This allows us to avoid recomputing
	// the file digest (which would be an expensive and racy procedure) while
	// still performing a stringent comparison.
	//
	// Notably absent from this comparison is an explicit equality check of the
	// Executability property of the expected entry with some computed
	// executability value. Unfortunately, this can't be done directly because
	// we may be on a filesystem that does not preserve exectuability
	// information. Indeed, the Executability property may have been set by the
	// executability propagation algorithm before reconciliation. We may also be
	// in a permissions mode where we're not recording executability information
	// in entries. Thus, we take an indirect comparison approach and simply
	// compare permission bits (as part a broader mode equivalence check) from
	// the current metadata and the cache. If these match, then we take it as an
	// indication that the permission bits which (via some mechanism in the
	// synchronization algorithm) generated the current Executability property
	// value are unchanged, and hence the Executability property value would be
	// unchanged as well if we were able to compute and compare it directly.
	match := metadata.Mode == filesystem.Mode(cached.Mode) &&
		metadata.ModificationTime.Equal(cached.ModificationTime.AsTime()) &&
		metadata.Size == cached.Size &&
		metadata.FileID == cached.FileID &&
		bytes.Equal(cached.Digest, expected.Digest)
	if !match {
		return errors.New("modification detected")
	}

	// Success.
	return nil
}

// ensureExpectedSymbolicLink ensures that the symbolic link specified by name
// within the specified directory matches the specified entry.
func (t *transitioner) ensureExpectedSymbolicLink(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Grab the link target.
	target, err := parent.ReadSymbolicLink(name)
	if err != nil {
		return fmt.Errorf("unable to read symbolic link target: %w", err)
	}

	// If we're in portable symbolic link mode, then we need to normalize the
	// target coming from disk, because some systems (e.g. Windows) won't
	// round-trip the target correctly.
	if t.symbolicLinkMode == SymbolicLinkMode_SymbolicLinkModePortable {
		target, err = normalizeSymbolicLinkAndEnsurePortable(path, target)
		if err != nil {
			return fmt.Errorf("unable to normalize target in portable mode: %w", err)
		}
	}

	// Ensure that the targets match.
	if target != expected.Target {
		return errors.New("symbolic link target does not match expected")
	}

	// Success.
	return nil
}

// removeFile removes the file specified by name within the specified directory,
// enforcing that it matches the specified entry.
func (t *transitioner) removeFile(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Ensure that the existing entry hasn't been modified from what we're
	// expecting.
	if err := t.ensureExpectedFile(parent, name, path, expected); err != nil {
		return fmt.Errorf("unable to validate existing file: %w", err)
	}

	// RACE: There is a race condition here between the file check and the file
	// removal that we have to live with due to limitations in filesystem APIs.
	// The worst case fallout is removal of contents that are modified during
	// this window.

	// Attempt to remove the file.
	return parent.RemoveFile(name)
}

// removeSymbolicLink removes the symbolic link specified by name within the
// specified directory, enforcing that it matches the specified entry.
func (t *transitioner) removeSymbolicLink(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Ensure that this request is valid for the current symbolic link mode.
	if t.symbolicLinkMode == SymbolicLinkMode_SymbolicLinkModeIgnore {
		return errors.New("symbolic link removal requested with symbolic links ignored")
	}

	// Ensure that the existing symbolic link hasn't been modified from what
	// we're expecting.
	if err := t.ensureExpectedSymbolicLink(parent, name, path, expected); err != nil {
		return fmt.Errorf("unable to validate existing symbolic link: %w", err)
	}

	// RACE: There is a race condition here between the symbolic link check and
	// the symbolic link removal that we have to live with due to limitations in
	// filesystem APIs. The worst case fallout is removal of contents that are
	// modified during this window.

	// Attempt to remove the symbolic link.
	return parent.RemoveSymbolicLink(name)
}

// removeDirectory (recursively) removes the directory specified by name within
// the specified directory, enforcing that it matches the specified entry. If
// only a portion of the directory can be removed, the provided entry will be
// reduced to represent what remains.
func (t *transitioner) removeDirectory(parent *filesystem.Directory, name, path string, expected *Entry) bool {
	// Open the directory itself. We don't defer its closure because we'll need
	// to explicitly close it before being able to remove it.
	directory, err := parent.OpenDirectory(name)
	if err != nil {
		t.recordProblem(path, fmt.Errorf("unable to open directory: %w", err))
		return false
	}

	// List the contents for this directory.
	contents, err := directory.ReadContents()
	if err != nil {
		directory.Close()
		t.recordProblem(path, fmt.Errorf("unable to read directory contents: %w", err))
		return false
	}

	// RACE: There is a race condition here between directory content listing
	// and removal that we have to live with due to limitations in filesystem
	// APIs. The worst case fallout from this race is that directory removal
	// will fail due to modifications that occur in this window.

	// Compute the prefix to add to content names to compute their paths.
	var contentPathPrefix string
	if len(contents) > 0 {
		contentPathPrefix = fastpath.Joinable(path)
	}

	// Loop through contents and remove them. We use the on-disk content listing
	// to ensure that what we're removing has the proper case. If we were to
	// just pass the OS whatever exists in our content map and the filesystem
	// were case-insensitive, we could delete a file that had been unmodified
	// but renamed (which we would still want to alert on). We also monitor for
	// cancellation during this iteration since it can block for a significant
	// period of time.
	var cancelled, unknownContentEncountered, contentRemovalFailed bool
ContentLoop:
	for _, c := range contents {
		// Check for cancellation.
		select {
		case <-t.cancelled:
			cancelled = true
			t.recordProblem(path, errTransitionCancelled)
			break ContentLoop
		default:
		}

		// Compute the content name, renormalizing Unicode if necessary.
		contentName := c.Name
		if t.recomposeUnicode {
			contentName = norm.NFC.String(contentName)
		}

		// Compute the content path.
		contentPath := contentPathPrefix + contentName

		// Grab the corresponding entry. If we don't know anything about this
		// entry, then mark that as a problem and ignore for now.
		entry, ok := expected.Contents[contentName]
		if !ok {
			unknownContentEncountered = true
			t.recordProblem(contentPath, errors.New("unknown content encountered on disk"))
			continue
		}

		// Handle content removal based on type.
		if entry.Kind == EntryKind_Directory {
			if !t.removeDirectory(directory, contentName, contentPath, entry) {
				contentRemovalFailed = true
				continue
			}
		} else if entry.Kind == EntryKind_File {
			if err = t.removeFile(directory, contentName, contentPath, entry); err != nil {
				contentRemovalFailed = true
				t.recordProblem(contentPath, fmt.Errorf("unable to remove file: %w", err))
				continue
			}
		} else if entry.Kind == EntryKind_SymbolicLink {
			if err = t.removeSymbolicLink(directory, contentName, contentPath, entry); err != nil {
				contentRemovalFailed = true
				t.recordProblem(contentPath, fmt.Errorf("unable to remove symbolic link: %w", err))
				continue
			}
		} else {
			contentRemovalFailed = true
			t.recordProblem(contentPath, errors.New("unknown entry type found in removal target"))
			continue
		}

		// At this point the removal must have succeeded, so remove the entry
		// from the target.
		delete(expected.Contents, contentName)
	}

	// If we weren't cancelled and we successfully removed all on-disk content,
	// then we can clear any remaining entries in the expected content map. This
	// map will likely be empty, but it won't be if it contains entries not seen
	// on disk (since we use the on-disk contents to drive iteration), in which
	// case those entries can just be treated as removed. We want to do this in
	// case directory removal fails (due to unknown content or failure to remove
	// the directory itself), because this entry will returned in that scenario,
	// and we want it to be as up-to-date as possible.
	if !cancelled && !contentRemovalFailed {
		expected.Contents = nil
	}

	// Close the directory.
	directory.Close()

	// RACE: There is a race condition here that is platform-dependent. On POSIX
	// platforms, the directory handle we had open (and whose content we
	// deleted) pointed to the directory by the given name in the parent at the
	// time of opening. It may have been unlinked, and we may have been
	// operating on something that wasn't visible on the filesystem.
	// Additionally, it may have been replaced by some other content with the
	// same name within the parent during this time. On Windows, holding open a
	// directory handle keeps it from being removed on the filesystem, but
	// there's still a window between the time that we close the directory and
	// the time we attempt to remove it. The worst case fallout in either case
	// is removal of content that was created with the same name during these
	// windows, or the apparent failure of the directory removal if the content
	// is of a different type.

	// If we weren't cancelled, didn't encounter any unknown content, and we
	// successfully removed all on-disk content, then we can attempt to remove
	// the directory itself.
	if !cancelled && !unknownContentEncountered && !contentRemovalFailed {
		if err := parent.RemoveDirectory(name); err != nil {
			t.recordProblem(path, fmt.Errorf("unable to remove directory: %w", err))
		} else {
			return true
		}
	}

	// At this point, we must have encountered some sort of problem earlier, but
	// it will already have been recorded, so we just need to make the removal
	// as failed.
	return false
}

// remove removes the content at the specified path, enforcing that it matches
// the specified entry. If only a portion of the content can be removed, then
// what remains will be represented by the return value.
func (t *transitioner) remove(path string, entry *Entry) *Entry {
	// If the entry is nil, we're done.
	if entry == nil {
		return nil
	}

	// Walk down to the parent of the target and compute the target's leaf name.
	// If we are successful, defer closure of the parent.
	parent, name, err := t.walkToParentAndComputeLeafName(path, true)
	if err != nil {
		t.recordProblem(path, fmt.Errorf("unable to walk to transition root: %w", err))
		return entry
	}
	defer parent.Close()

	// Handle removal based on type.
	if entry.Kind == EntryKind_Directory {
		// Create a copy of entry for mutation.
		entryCopy := entry.Copy(EntryCopyBehaviorDeepPreservingLeaves)

		// Attempt to reduce it.
		if !t.removeDirectory(parent, name, path, entryCopy) {
			return entryCopy
		}
	} else if entry.Kind == EntryKind_File {
		if err := t.removeFile(parent, name, path, entry); err != nil {
			t.recordProblem(path, fmt.Errorf("unable to remove file: %w", err))
			return entry
		}
	} else if entry.Kind == EntryKind_SymbolicLink {
		if err := t.removeSymbolicLink(parent, name, path, entry); err != nil {
			t.recordProblem(path, fmt.Errorf("unable to remove symbolic link: %w", err))
			return entry
		}
	} else {
		t.recordProblem(path, errors.New("removal requested for unknown entry type"))
		return entry
	}

	// Success.
	return nil
}

// findAndMoveStagedFileIntoPlace locates a staged file for the specified
// combination of path and entry, sets its permissions appropriately, and moves
// it to the location specified by the combination of parent directory and
// content name. If this requires a cross-device rename, this function will
// approximate atomicity using an intermediate temporary file.
func (t *transitioner) findAndMoveStagedFileIntoPlace(
	path string,
	target *Entry,
	parent *filesystem.Directory,
	name string,
	replace bool,
) error {
	// Compute the new file mode. If we're in a mode where executability
	// information is being propagated, then we'll already have enforced that
	// the default file mode doesn't contain executability bits, and therefore
	// we don't need to strip them out in the event that executability isn't
	// set for the entry. If we're in a mode where executability information
	// isn't being propagated, then no entries will be marked as executable and
	// we'll use the default file mode, which will also have been validated.
	mode := t.defaultFileMode
	if target.Executable {
		mode = markExecutableForReaders(mode)
	}

	// Compute the path to the staged file. This does not ensure that the file
	// exists, which we'll instead detect when setting permissions or attempting
	// to rename or copy the file into place.
	stagedPath, err := t.provider.Provide(path, target.Digest)
	if err != nil {
		return fmt.Errorf("unable to compute staged file path: %w", err)
	}

	// Set permissions for the staged file. When performing this operation, we
	// check for non-existence of the file, because Provide doesn't guarantee
	// that it exists.
	if err := filesystem.SetPermissionsByPath(stagedPath, t.defaultOwnership, mode); err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			t.providerMissingFiles = true
		}
		return fmt.Errorf("unable to set staged file permissions: %w", err)
	}

	// Attempt to atomically rename the file into place. If the atomic rename
	// fails, then check if it was due to a cross-device rename. If not, then
	// there's nothing else we can do.
	//
	// We also check for non-existence here, just in case it isn't caught by
	// SetPermissionsByPath (which can be a no-op). Note that a non-existence
	// error on a rename operation can also result from the destination path not
	// existing, but that can't be the case here given that our destination is
	// targeted by an open handle and thus must exist (even if unlinked from the
	// filesystem).
	renameErr := filesystem.Rename(nil, stagedPath, parent, name, replace)
	if renameErr == nil {
		return nil
	} else if !filesystem.IsCrossDeviceError(renameErr) {
		if errors.Is(renameErr, fs.ErrNotExist) {
			t.providerMissingFiles = true
		}
		return fmt.Errorf("unable to relocate staged file: %w", renameErr)
	}

	// At this point, we know we're dealing with a cross-device rename, for
	// which we'll have to simulate atomicity with an intermediate temporary
	// file. We'll also need to monitor for preemption at this point because
	// cross-device copies can take a significant amount of time.

	// Open the staged file. We can't defer its closure because we need to be
	// able to remove it after a successful rename, which we can't do (on some
	// platforms, notably Windows) if the file handle is open.
	//
	// This is also the last place we check for non-existence, because
	// SetPermissionsByPath can be a no-op and the rename operation may
	// prioritize the cross-device error over any non-existence error (even
	// though that seems unlikely, since the OS be assuming cross-device copying
	// based on the source and destination directories alone). In any case,
	// we're now opening the actual target file, so if it doesn't exist, we'll
	// know for sure.
	stagedFile, err := os.Open(stagedPath)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			t.providerMissingFiles = true
		}
		return fmt.Errorf("unable to open staged file: %w", err)
	}

	// Create a temporary file in the target directory. We can't defer its
	// closure because we'll want to be rename it or remove it on rename
	// failure, which we can't do (on some platforms, notably Windows) if the
	// file handle is open.
	temporaryName, temporary, err := parent.CreateTemporaryFile(crossDeviceRenameTemporaryNamePrefix)
	if err != nil {
		stagedFile.Close()
		return fmt.Errorf("unable to create temporary file for cross-device rename: %w", err)
	}

	// Wrap the temporary file in a preemptable writer to enable cancellation.
	preemptableTemporary := stream.NewPreemptableWriter(
		temporary,
		t.cancelled,
		transitionCopyPreemptionInterval,
	)

	// Copy the file contents. We'll handle errors below.
	_, copyErr := io.CopyBuffer(preemptableTemporary, stagedFile, t.copyBuffer)

	// Close out files.
	stagedFile.Close()
	temporary.Close()

	// If there was a copy error, then remove the temporary and abort.
	if copyErr != nil {
		parent.RemoveFile(temporaryName)
		if errors.Is(copyErr, stream.ErrWritePreempted) {
			return errTransitionCancelled
		}
		return fmt.Errorf("unable to copy file contents: %w", copyErr)
	}

	// Set permissions on the temporary file.
	if err := parent.SetPermissions(temporaryName, t.defaultOwnership, mode); err != nil {
		parent.RemoveFile(temporaryName)
		return fmt.Errorf("unable to set intermediate file permissions: %w", err)
	}

	// Rename the file.
	if err := filesystem.Rename(parent, temporaryName, parent, name, replace); err != nil {
		parent.RemoveFile(temporaryName)
		return fmt.Errorf("unable to relocate intermediate file: %w", err)
	}

	// Remove the staged file. We don't bother checking for errors because
	// there's not much we can or need to do about them at this point.
	os.Remove(stagedPath)

	// Success.
	return nil
}

// swapFile atomically swaps files at the specified path, enforcing that the
// existing file matches what's expected.
func (t *transitioner) swapFile(path string, oldEntry, newEntry *Entry) error {
	// Walk down to the parent of the target and compute the target's leaf name.
	// If we are successful, defer closure of the parent.
	parent, name, err := t.walkToParentAndComputeLeafName(path, true)
	if err != nil {
		return fmt.Errorf("unable to walk to transition root: %w", err)
	}
	defer parent.Close()

	// Ensure that the existing entry hasn't been modified from what we're
	// expecting.
	if err := t.ensureExpectedFile(parent, name, path, oldEntry); err != nil {
		return fmt.Errorf("unable to validate existing file: %w", err)
	}

	// RACE: There is a race condition here between the file check and the file
	// replacement that we have to live with due to limitations in filesystem
	// APIs. The worst case fallout is replacement of contents that are modified
	// during this window.

	// If both files have the same contents (differing only in executability),
	// then we won't have staged the file, so we just change the permissions on
	// the existing file.
	if bytes.Equal(oldEntry.Digest, newEntry.Digest) {
		// Compute the new file mode. If we're in a mode where executability
		// information is being propagated (which is the only type of mode that
		// we could be in on this particular code branch), then we'll already
		// have enforced that the default file mode doesn't contain
		// executability bits, and therefore we don't need to strip them out in
		// the event that executability isn't set.
		mode := t.defaultFileMode
		if newEntry.Executable {
			mode = markExecutableForReaders(mode)
		}

		// Attempt to change file permissions.
		//
		// TODO: If we were to pass in executability preservation information to
		// the transitioner, we could skip this call on systems where
		// executability information is not preserved.
		if err := parent.SetPermissions(name, t.defaultOwnership, mode); err != nil {
			return fmt.Errorf("unable to change file permissions: %w", err)
		}

		// Success.
		return nil
	}

	// Otherwise, we will have a staged file, so find it and move it into place.
	return t.findAndMoveStagedFileIntoPlace(path, newEntry, parent, name, true)
}

// createFile creates the target file at the specified path.
func (t *transitioner) createFile(parent *filesystem.Directory, name, path string, target *Entry) error {
	return t.findAndMoveStagedFileIntoPlace(path, target, parent, name, false)
}

// createSymbolicLink creates the target symbolic link at the specified path.
func (t *transitioner) createSymbolicLink(parent *filesystem.Directory, name, path string, target *Entry) error {
	// Verify that the symbolic link agrees with our symbolic link mode.
	if t.symbolicLinkMode == SymbolicLinkMode_SymbolicLinkModeIgnore {
		return errors.New("symbolic link creation requested with symbolic links ignored")
	} else if t.symbolicLinkMode == SymbolicLinkMode_SymbolicLinkModePortable {
		if normalized, err := normalizeSymbolicLinkAndEnsurePortable(path, target.Target); err != nil || normalized != target.Target {
			return errors.New("symbolic link was not in normalized form or was not portable")
		}
	}

	// Create the symbolic link.
	if err := parent.CreateSymbolicLink(name, target.Target); err != nil {
		return err
	}

	// RACE: There is a race condition here between the creation of the symbolic
	// link and the setting of its ownership/permissions that we have to live
	// with due to limitations in filesystem APIs. The worst case fallout is
	// that permissions are set for a newly created filesystem entry at the same
	// path, but it would generally inherit the same permissions over time since
	// it's also within the synchronization path.

	// Set permissions on the symbolic link. For permissions, we always use the
	// executable form of the file mode, mirroring whats' done by the operating
	// system (even for non-executable files).
	//
	// HACK: On Linux, the AT_SYMLINK_NOFOLLOW flag is not supported by
	// fchmodat, so our SetPermissions function works around this with an
	// alternative implementation. Unfortunately this implementation also
	// doesn't support setting the mode bits for a symbolic link directly, which
	// seems to be something that Linux doesn't support in general (though it
	// does support symbolic link ownership). Thus, we zero-out the mode bits on
	// Linux to skip permission setting (while retaining ownership setting).
	mode := markExecutableForReaders(t.defaultFileMode)
	if runtime.GOOS == "linux" {
		mode = 0
	}
	if err := parent.SetPermissions(name, t.defaultOwnership, mode); err != nil {
		return fmt.Errorf("unable to set symbolic link permissions: %w", err)
	}

	// Success.
	return nil
}

// createDirectory creates the target directory at the specified path. If only a
// portion of the directory can be created, an entry representing that portion
// will be returned.
func (t *transitioner) createDirectory(parent *filesystem.Directory, name, path string, target *Entry) *Entry {
	// Attempt to create the directory.
	if err := parent.CreateDirectory(name); err != nil {
		t.recordProblem(path, fmt.Errorf("unable to create directory: %w", err))
		return nil
	}

	// Create a slim copy of the target that we'll populate as we create its
	// contents.
	created := target.Copy(EntryCopyBehaviorSlim)

	// RACE: There is a race condition here between the directory creation and
	// the permission setting and the creation of the directory's contents that
	// we have to live with due to limitations in filesystem APIs. The worst
	// case fallout is that the directory has been replaced by another file on
	// which permissions are set and modifications are made. If this other
	// object is a non-directory, then errors will arise quickly.

	// Set directory permissions. If this fails, we abort the remainder of the
	// operation because it's indicative of the fact that something's wrong.
	// However, since we did succeed in creating the directory, we return that
	// portion.
	if err := parent.SetPermissions(name, t.defaultOwnership, t.defaultDirectoryMode); err != nil {
		t.recordProblem(path, fmt.Errorf("unable to set directory permissions: %w", err))
		return created
	}

	// If there are contents in the target, allocate a map for created, because
	// we'll need to populate it, and open the directory for operations
	// (deferring its closure).
	var directory *filesystem.Directory
	if len(target.Contents) > 0 {
		// Allocate the content map.
		created.Contents = make(map[string]*Entry, len(target.Contents))

		// Open the directory.
		if d, err := parent.OpenDirectory(name); err != nil {
			t.recordProblem(path, fmt.Errorf("unable to open new directory: %w", err))
			return created
		} else {
			directory = d
			defer directory.Close()
		}
	}

	// Compute the prefix to add to content names to compute their paths.
	var contentPathPrefix string
	if len(target.Contents) > 0 {
		contentPathPrefix = fastpath.Joinable(path)
	}

	// Attempt to create the target contents. We monitor for cancellation during
	// this creation since it can block for a significant period of time.
ContentLoop:
	for name, entry := range target.Contents {
		// Check for cancellation.
		select {
		case <-t.cancelled:
			t.recordProblem(path, errTransitionCancelled)
			break ContentLoop
		default:
		}

		// Compute the content path.
		contentPath := contentPathPrefix + name

		// Handle content creation based on type.
		if entry.Kind == EntryKind_Directory {
			if c := t.createDirectory(directory, name, contentPath, entry); c != nil {
				created.Contents[name] = c
			}
		} else if entry.Kind == EntryKind_File {
			if err := t.createFile(directory, name, contentPath, entry); err != nil {
				t.recordProblem(contentPath, fmt.Errorf("unable to create file: %w", err))
			} else {
				created.Contents[name] = entry
			}
		} else if entry.Kind == EntryKind_SymbolicLink {
			if err := t.createSymbolicLink(directory, name, contentPath, entry); err != nil {
				t.recordProblem(contentPath, fmt.Errorf("unable to create symbolic link: %w", err))
			} else {
				created.Contents[name] = entry
			}
		} else {
			t.recordProblem(contentPath, errors.New("creation requested for unknown entry type"))
		}
	}

	// Return the portion of the target that was created.
	return created
}

// create creates the target content at the specified path. If only a portion of
// the content can be created, an entry representing that portion will be
// returned.
func (t *transitioner) create(path string, target *Entry) *Entry {
	// If the target is nil, we're done.
	if target == nil {
		return nil
	}

	// Walk down to the parent of the target and compute the target's leaf name.
	// If we are successful, defer closure of the parent.
	parent, name, err := t.walkToParentAndComputeLeafName(path, false)
	if err != nil {
		t.recordProblem(path, fmt.Errorf("unable to walk to transition root parent: %w", err))
		return nil
	}
	defer parent.Close()

	// Handle creation based on type.
	if target.Kind == EntryKind_Directory {
		return t.createDirectory(parent, name, path, target)
	} else if target.Kind == EntryKind_File {
		if err := t.createFile(parent, name, path, target); err != nil {
			t.recordProblem(path, fmt.Errorf("unable to create file: %w", err))
			return nil
		} else {
			return target
		}
	} else if target.Kind == EntryKind_SymbolicLink {
		if err := t.createSymbolicLink(parent, name, path, target); err != nil {
			t.recordProblem(path, fmt.Errorf("unable to create symbolic link: %w", err))
			return nil
		} else {
			return target
		}
	} else {
		t.recordProblem(path, errors.New("creation requested for unknown entry type"))
		return nil
	}
}

// Transition provides recursive filesystem transitioning facilities for
// synchronization roots, allowing the application of changes after
// reconciliation. The path to the provided synchronization root must be
// absolute and normalized (using filepath.Clean). The function returns a slice
// of the resulting entries, problems, and a boolean indicating whether or not
// the provider was missing files.
func Transition(
	ctx context.Context,
	root string,
	transitions []*Change,
	cache *Cache,
	symbolicLinkMode SymbolicLinkMode,
	defaultFileMode filesystem.Mode,
	defaultDirectoryMode filesystem.Mode,
	defaultOwnership *filesystem.OwnershipSpecification,
	recomposeUnicode bool,
	provider Provider,
) ([]*Entry, []*Problem, bool) {
	// Extract the cancellation channel.
	cancelled := ctx.Done()

	// Create the transitioner.
	transitioner := &transitioner{
		cancelled:            cancelled,
		root:                 root,
		cache:                cache,
		symbolicLinkMode:     symbolicLinkMode,
		defaultFileMode:      defaultFileMode,
		defaultDirectoryMode: defaultDirectoryMode,
		defaultOwnership:     defaultOwnership,
		copyBuffer:           make([]byte, transitionCopyBufferSize),
		recomposeUnicode:     recomposeUnicode,
		provider:             provider,
	}

	// Set up results.
	var results []*Entry

	// Iterate through transitions.
	for _, t := range transitions {
		// Check for cancellation. Even if cancelled, we still need to yield a
		// result, so we'll continue looping through transitions and just mark
		// them as having encountered cancellation.
		select {
		case <-cancelled:
			results = append(results, t.Old)
			transitioner.recordProblem(t.Path, errTransitionCancelled)
			continue
		default:
		}

		// Handle the special case where both old and new are a file. In this
		// case we can do a simple swap. It makes sense to handle this specially
		// because it is a very common case and doing it with a swap will remove
		// any window where the path is empty on the filesystem.
		fileToFile := t.Old != nil && t.New != nil &&
			t.Old.Kind == EntryKind_File &&
			t.New.Kind == EntryKind_File
		if fileToFile {
			if err := transitioner.swapFile(t.Path, t.Old, t.New); err != nil {
				results = append(results, t.Old)
				transitioner.recordProblem(t.Path, fmt.Errorf("unable to swap file: %w", err))
			} else {
				results = append(results, t.New)
			}
			continue
		}

		// Reduce whatever we expect to see on disk to nil (remove it). If we
		// don't expect to see anything (t.Old == nil), this is a no-op. If this
		// fails, then record the reduced entry and continue to the next
		// transition.
		if r := transitioner.remove(t.Path, t.Old); r != nil {
			results = append(results, r)
			continue
		}

		// At this point, we should have nil on disk. Transition to whatever the
		// new entry is (or at least as much of it as we can create). If the new
		// entry is nil, then this is a no-op.
		results = append(results, transitioner.create(t.Path, t.New))
	}

	// Done.
	return results, transitioner.problems, transitioner.providerMissingFiles
}
