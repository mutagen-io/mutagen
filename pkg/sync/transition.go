package sync

import (
	"bytes"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/pkg/errors"

	"golang.org/x/text/unicode/norm"

	"github.com/golang/protobuf/ptypes"

	"github.com/havoc-io/mutagen/pkg/filesystem"
)

const (
	// crossDeviceRenameTemporaryNamePrefix is the file name prefix to use for
	// intermediate temporary files used in cross-device renames.
	crossDeviceRenameTemporaryNamePrefix = filesystem.TemporaryNamePrefix + "cross-device-rename"
)

// Provider defines the interface that higher-level logic can use to provide
// files to transition algorithms.
type Provider interface {
	// Provide returns a filesystem path to a file containing the contents for
	// the path given as the first argument with the digest specified by the
	// second argument. If the provider is unable to locate a file matching the
	// specified parameters in its internal storage, it should return an error
	// for which os.IsNotExist evaluates to true.
	Provide(path string, digest []byte) (string, error)
}

// transitioner provides the recursive implementation of transitioning.
type transitioner struct {
	// root is the path to the synchronization root.
	root string
	// cache is the file digest cache generated by scan.
	cache *Cache
	// symlinkMode is the symlink mode to use for synchronization. It's required
	// to verify existing symlinks (which may require normalization).
	symlinkMode SymlinkMode
	// defaultFilePermissionMode is the default file permission mode to use in
	// "portable" permission propagation.
	defaultFilePermissionMode filesystem.Mode
	// defaultDirectoryPermissionMode is the default directory permission mode
	// to use in "portable" permission propagation.
	defaultDirectoryPermissionMode filesystem.Mode
	// defaultOwnership is the default ownership specification to use in
	// "portable" permission propagation.
	defaultOwnership *filesystem.OwnershipSpecification
	// recomposeUnicode indicates whether or not filenames need to be recomposed
	// due to Unicode decomposition behavior on the synchronization root
	// filesystem.
	recomposeUnicode bool
	// provider is the staged file provider.
	provider Provider
	// problems are the problems currently being tracked.
	problems []*Problem
	// providerMissingFiles indicates that the staged file provider returned an
	// os.IsNotExist error for at least one file that was expected to be staged.
	providerMissingFiles bool
}

// recordProblem records a new problem.
func (t *transitioner) recordProblem(path string, err error) {
	t.problems = append(t.problems, &Problem{Path: path, Error: err.Error()})
}

// nameExistsInDirectoryWithProperCase is a utility method that checks if a name
// exists within the specified directory, recomposing the names of the
// directory's contents if necessary.
func (t *transitioner) nameExistsInDirectoryWithProperCase(
	name string,
	directory *filesystem.Directory,
) (bool, error) {
	// Grab the content names in the directory.
	names, err := directory.ReadContentNames()
	if err != nil {
		return false, errors.Wrap(err, "unable to read directory contents")
	}

	// Check if this path component exists in the contents. It's important
	// to note that the contents are not guaranteed to be ordered, and we
	// may need to recompose Unicode, so we can't do a binary search here.
	for _, n := range names {
		if !t.recomposeUnicode && n == name {
			return true, nil
		} else if t.recomposeUnicode && norm.NFC.String(n) == name {
			return true, nil
		}
	}

	// No match was found.
	return false, nil
}

// walkToParentAndComputeLeafName walks down to the parent directory of the
// specified path, verifying proper casing at each step, and optionally
// validating the casing of the path leaf. It returns the Directory object
// representing the parent path and the base name of the path, or an error if
// this operation fails. If provided a root (empty) path, it will open the
// parent directory of the root path and return the base name of the root path.
// If the parent directory does not exist, this method will create it if
// requested.
//
// The purpose of this function is to transform any transition operation into
// one where we have a Directory object for race-free filesystem access, the
// base name of the content within that directory which needs to be transformed,
// and (external to this function) the old and new content specifications.
//
// This method's implementation also has the side effect of enforcing case
// correctness. If verifyLeafCasing is true, then this method will additionally
// verify that the casing of the leaf name of the path matches what's on the
// filesystem.
func (t *transitioner) walkToParentAndComputeLeafName(
	path string,
	validateLeafCasing bool,
) (*filesystem.Directory, string, error) {
	// Handle the special case of a root path. In this case we open the parent
	// directory of the synchronization root and return the base name of the
	// synchronization root.
	if path == "" {
		// Split the synchronization root path into parent path and base name.
		// If the base name is empty, it means that the synchronization root
		// path represents the filesystem root (i.e. '/' on POSIX systems and
		// a drive root on Windows). If this is the case, then return an error,
		// because we need to be able to access the root's parent in order to
		// modify the root itself. In practice, this is fine, because there are
		// no transitions that we could perform on a filesystem root anyway (it
		// will always just be a directory).
		//
		// Note that we're assuming here that the path is absolute and
		// normalized (i.e. it's not something like "/component/"). This is fine
		// because we require this for synchronization root paths passed to
		// Transition.
		rootParentPath, rootName := filepath.Split(t.root)
		if rootName == "" {
			return nil, "", errors.New("root path is a filesystem root")
		}

		// Open the parent. We do allow the parent path to be a symbolic link
		// since we allow symbolic link resolution for parent components of the
		// synchronization root (just not at the synchronization root itself).
		if rootParent, _, err := filesystem.OpenDirectory(rootParentPath, true); err != nil {
			return nil, "", errors.Wrap(err, "unable to open synchronization root parent directory")
		} else {
			return rootParent, rootName, nil
		}
	}

	// Split the path and extract the parent components and leaf name.
	components := strings.Split(path, "/")
	parentComponents := components[:len(components)-1]
	leafName := components[len(components)-1]

	// Open the root path. If it's not a directory, then this operation isn't
	// valid.
	parent, _, err := filesystem.OpenDirectory(t.root, false)
	if err != nil {
		return nil, "", errors.Wrap(err, "unable to open synchronization root")
	}

	// Traverse through parent components, validating casing as we go and moving
	// down the directory hierarchy.
	for _, component := range parentComponents {
		// Verify that the next component exists with the proper casing.
		if found, err := t.nameExistsInDirectoryWithProperCase(component, parent); err != nil {
			parent.Close()
			return nil, "", errors.Wrap(err, "unable to verify parent path casing")
		} else if !found {
			parent.Close()
			return nil, "", errors.New("parent path does not exist or has incorrect casing")
		}

		// RACE: There is technically a race condition here because the path
		// could be removed and recreated with a different case between our
		// check and the time that we open it. Unfortunately there's nothing we
		// can do about this - case insensitive filesystems simply suffer this
		// issue. The worst case fallout here is not severe. Case insensitive
		// filesystems won't allow two names which differ only in casing, so
		// technically we're still opening the "right" path, though arguably not
		// so in the context of our synchronization algorithm (which is
		// case-sensitive). Case sensitive filesystems don't suffer from any
		// issue here. In any case, the synchronization algorithm will see the
		// correct casing on the next synchronization cycle.

		// Open the next directory.
		if p, err := parent.OpenDirectory(component); err != nil {
			parent.Close()
			return nil, "", errors.Wrap(err, "unable to open parent component")
		} else {
			parent.Close()
			parent = p
		}
	}

	// Once we've extracted the parent, validate the leaf name casing if
	// requested.
	if validateLeafCasing {
		if found, err := t.nameExistsInDirectoryWithProperCase(leafName, parent); err != nil {
			parent.Close()
			return nil, "", errors.Wrap(err, "unable to verify path leaf name casing")
		} else if !found {
			parent.Close()
			return nil, "", errors.New("leaf name does not exist or has incorrect casing")
		}
	}

	// Success.
	return parent, leafName, nil
}

// ensureExpectedFile ensures that the file specified by name within the
// specified directory matches the specified entry.
func (t *transitioner) ensureExpectedFile(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Grab cache information for this path. If we can't find it, we treat this
	// as an immediate fail. This is a bit of a heuristic/hack, because we could
	// recompute the digest of what's on disk, but for our use case this is very
	// expensive and we SHOULD already have this information cached from the
	// last scan.
	cached, ok := t.cache.Entries[path]
	if !ok {
		return errors.New("unable to find cache information for path")
	}

	// Grab metadata for this path.
	metadata, err := parent.ReadContentMetadata(name)
	if err != nil {
		return errors.Wrap(err, "unable to grab file statistics")
	}

	// Convert the timestamp to Protocol Buffers format.
	modificationTimeProto, err := ptypes.TimestampProto(metadata.ModificationTime)
	if err != nil {
		return errors.Wrap(err, "unable to convert modification time format")
	}

	// Instead of comparing directly against the expected entry, compare the
	// current metadata with that in the cache. If that matches, compare the
	// cached digest with that of the entry. This allows us to avoid recomputing
	// the file digest (which would be an expensive and racy procedure) while
	// still performing a stringent comparison.
	//
	// Notably absent from this comparison is an explicit equality check of the
	// Executability property of the expected entry with some computed
	// executability value. Unfortunately this can't be done directly, because
	// we may be on a filesystem that does not preserve exectuability
	// information. Indeed, the Executability property may have been set by the
	// executability propagation algorithm before reconciliation. Instead, we
	// take an indirect comparison approach and simply compare permission bits
	// (as part of the mode equivalence check) from the current metadata and the
	// cache. If these match, we take it as an indication that the permission
	// bits which (via some mechanism in the synchronization algorithm)
	// generated the current Executability property value are unchanged, and
	// hence the Executability property value would be unchanged as well if we
	// were able to compute and compare it directly.
	match := metadata.Mode == filesystem.Mode(cached.Mode) &&
		modificationTimeProto.Seconds == cached.ModificationTime.Seconds &&
		modificationTimeProto.Nanos == cached.ModificationTime.Nanos &&
		metadata.Size == cached.Size &&
		metadata.FileID == cached.FileID &&
		bytes.Equal(cached.Digest, expected.Digest)
	if !match {
		return errors.New("modification detected")
	}

	// Success.
	return nil
}

// ensureExpectedSymbolicLink ensures that the symbolic link specified by name
// within the specified directory matches the specified entry.
func (t *transitioner) ensureExpectedSymbolicLink(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Grab the link target.
	target, err := parent.ReadSymbolicLink(name)
	if err != nil {
		return errors.Wrap(err, "unable to read symlink target")
	}

	// If we're in portable symlink mode, then we need to normalize the target
	// coming from disk, because some systems (e.g. Windows) won't round-trip
	// the target correctly.
	if t.symlinkMode == SymlinkMode_SymlinkModePortable {
		target, err = normalizeSymlinkAndEnsurePortable(path, target)
		if err != nil {
			return errors.Wrap(err, "unable to normalize target in portable mode")
		}
	}

	// Ensure that the targets match.
	if target != expected.Target {
		return errors.New("symlink target does not match expected")
	}

	// Success.
	return nil
}

// ensureNotExists ensures that no content with the specified name exists within
// the specified directory.
func (t *transitioner) ensureNotExists(parent *filesystem.Directory, name string) error {
	// Attempt to grab stat information for the path.
	_, err := parent.ReadContentMetadata(name)

	// Handle error cases (which may indicate success).
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return errors.Wrap(err, "unable to determine path existence")
	}

	// Failure.
	return errors.New("path exists")
}

// removeFile removes the file specified by name within the specified directory,
// enforcing that it matches the specified entry.
func (t *transitioner) removeFile(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Ensure that the existing entry hasn't been modified from what we're
	// expecting.
	if err := t.ensureExpectedFile(parent, name, path, expected); err != nil {
		return errors.Wrap(err, "unable to validate existing file")
	}

	// RACE: There is a race condition here between the file check and the file
	// removal that we have to live with due to limitations in filesystem APIs.
	// The worst case fallout is removal of contents that are modified during
	// this window.

	// Remove the file.
	return parent.RemoveFile(name)
}

// removeSymbolicLink removes the symbolic link specified by name within the
// specified directory, enforcing that it matches the specified entry.
func (t *transitioner) removeSymbolicLink(parent *filesystem.Directory, name, path string, expected *Entry) error {
	// Ensure that this request is valid for the current symbolic link handling
	// mode.
	if t.symlinkMode == SymlinkMode_SymlinkModeIgnore {
		return errors.New("symbolic link removal requested with symbolic links ignored")
	}

	// Ensure that the existing symlink hasn't been modified from what we're
	// expecting.
	if err := t.ensureExpectedSymbolicLink(parent, name, path, expected); err != nil {
		return errors.Wrap(err, "unable to validate existing symbolic link")
	}

	// RACE: There is a race condition here between the symbolic link check and
	// the symbolic link removal that we have to live with due to limitations in
	// filesystem APIs. The worst case fallout is removal of contents that are
	// modified during this window.

	// Remove the symlink.
	return parent.RemoveSymbolicLink(name)
}

// removeDirectory (recursively) removes the directory specified by name within
// the specified directory, enforcing that it matches the specified entry. If
// only a portion of the directory can be removed, the provided entry will be
// reduced to represent what remains.
func (t *transitioner) removeDirectory(parent *filesystem.Directory, name, path string, expected *Entry) bool {
	// Open the directory itself. We don't defer its closure because we'll need
	// to explicitly close it before being able to remove it.
	directory, err := parent.OpenDirectory(name)
	if err != nil {
		t.recordProblem(path, errors.Wrap(err, "unable to open directory"))
		return false
	}

	// List the contents for this directory.
	contents, err := directory.ReadContents()
	if err != nil {
		directory.Close()
		t.recordProblem(path, errors.Wrap(err, "unable to read directory contents"))
		return false
	}

	// RACE: There is a race condition here between directory content listing
	// and removal that we have to live with due to limitations in filesystem
	// APIs. The worst case fallout from this race is that directory removal
	// will fail due to modifications that occur in this window.

	// Loop through contents and remove them. We do this to ensure that what
	// we're removing has the proper case. If we were to just pass the OS what
	// exists in our content map and it were case insensitive, we could delete
	// a file that had been unmodified but renamed.
	unknownContentEncountered := false
	for _, c := range contents {
		// Compute the content name, renormalizing Unicode if necessary.
		contentName := c.Name
		if t.recomposeUnicode {
			contentName = norm.NFC.String(contentName)
		}

		// Compute the content path.
		contentPath := pathJoin(path, contentName)

		// Grab the corresponding entry. If we don't know anything about this
		// entry, then mark that as a problem and ignore for now.
		entry, ok := expected.Contents[contentName]
		if !ok {
			t.recordProblem(contentPath, errors.New("unknown content encountered on disk"))
			unknownContentEncountered = true
			continue
		}

		// Handle content removal based on type.
		if entry.Kind == EntryKind_Directory {
			if !t.removeDirectory(directory, contentName, contentPath, entry) {
				continue
			}
		} else if entry.Kind == EntryKind_File {
			if err = t.removeFile(directory, contentName, contentPath, entry); err != nil {
				t.recordProblem(contentPath, errors.Wrap(err, "unable to remove file"))
				continue
			}
		} else if entry.Kind == EntryKind_Symlink {
			if err = t.removeSymbolicLink(directory, contentName, contentPath, entry); err != nil {
				t.recordProblem(contentPath, errors.Wrap(err, "unable to remove symbolic link"))
				continue
			}
		} else {
			t.recordProblem(contentPath, errors.New("unknown entry type found in removal target"))
			continue
		}

		// At this point the removal must have succeeded, so remove the entry
		// from the target.
		delete(expected.Contents, contentName)
	}

	// Close the directory.
	directory.Close()

	// RACE: There is a race condition here that is platform-dependent. On POSIX
	// platforms, the directory handle we had open (and whose content we
	// deleted) pointed to the directory by the given name in the parent at the
	// time of opening. It may have been unlinked, and we may have been
	// operating on something that wasn't visible on the filesystem.
	// Additionally, it may have been replaced by some other content with the
	// same name within the parent during this time. On Windows, holding open a
	// directory handle keeps it from being removed on the filesystem, but
	// there's still a window between the time that we close the directory and
	// the time we attempt to remove it. The worst case fallout in either case
	// is removal of content that was created with the same name during these
	// windows, or the apparent failure of the directory removal if the content
	// is of a different type.

	// If we didn't encounter any unknown content and the target contents are
	// empty, then we can attempt to remove the directory itself.
	if !unknownContentEncountered && len(expected.Contents) == 0 {
		if err := parent.RemoveDirectory(name); err != nil {
			t.recordProblem(path, errors.Wrap(err, "unable to remove directory"))
		} else {
			return true
		}
	}

	// At this point, we must have encountered some sort of problem earlier, but
	// it will already have been recorded, so we just need to make the removal
	// as failed.
	return false
}

// remove removes the content at the specified path, enforcing that it matches
// the specified entry. If only a portion of the content can be removed, then
// what remains will be represented by the return value.
func (t *transitioner) remove(path string, entry *Entry) *Entry {
	// If the entry is nil, we're done.
	if entry == nil {
		return nil
	}

	// Walk down to the parent of the target and compute the target's leaf name.
	// If we are successful, defer closure of the parent.
	parent, name, err := t.walkToParentAndComputeLeafName(path, true)
	if err != nil {
		t.recordProblem(path, errors.Wrap(err, "unable to walk to transition root"))
		return entry
	}
	defer parent.Close()

	// Handle removal based on type.
	if entry.Kind == EntryKind_Directory {
		// Create a copy of entry for mutation.
		entryCopy := entry.Copy()

		// Attempt to reduce it.
		if !t.removeDirectory(parent, name, path, entryCopy) {
			return entryCopy
		}
	} else if entry.Kind == EntryKind_File {
		if err := t.removeFile(parent, name, path, entry); err != nil {
			t.recordProblem(path, errors.Wrap(err, "unable to remove file"))
			return entry
		}
	} else if entry.Kind == EntryKind_Symlink {
		if err := t.removeSymbolicLink(parent, name, path, entry); err != nil {
			t.recordProblem(path, errors.Wrap(err, "unable to remove symlink"))
			return entry
		}
	} else {
		t.recordProblem(path, errors.New("removal requested for unknown entry type"))
		return entry
	}

	// Success.
	return nil
}

// findAndMoveStagedFileIntoPlace locates a staged file for the specified
// combination of path and entry, sets its permissions appropriately, and moves
// it to the location specified by the combination of parent directory and
// content name. If this requires a cross-device rename, this function will
// approximate atomicity using an intermediate temporary file.
func (t *transitioner) findAndMoveStagedFileIntoPlace(
	path string,
	target *Entry,
	parent *filesystem.Directory,
	name string,
) error {
	// Compute the new file mode based on the new entry's executability. We
	// enforce that default file modes don't have executability bits set, so we
	// don't need to strip them out in the event that executability isn't set.
	mode := t.defaultFilePermissionMode
	if target.Executable {
		mode = markExecutableForReaders(mode)
	}

	// Compute the path to the staged file. If the provider indicates that no
	// staged file exists with the specified parameters, then update our missing
	// file tracking.
	stagedPath, err := t.provider.Provide(path, target.Digest)
	if err != nil {
		if os.IsNotExist(err) {
			t.providerMissingFiles = true
		}
		return errors.Wrap(err, "unable to locate staged file")
	}

	// Set permissions for the staged file.
	if err := filesystem.SetPermissionsByPath(stagedPath, t.defaultOwnership, mode); err != nil {
		return errors.Wrap(err, "unable to set staged file permissions")
	}

	// Attempt to atomically rename the file. If we succeed, we're done.
	renameErr := filesystem.Rename(nil, stagedPath, parent, name)
	if renameErr == nil {
		return nil
	}

	// If the atomic rename failed, check if it was due to a cross-device
	// rename. If not, then there's nothing else we can do.
	if !filesystem.IsCrossDeviceError(renameErr) {
		return errors.Wrap(renameErr, "unable to relocate staged file")
	}

	// At this point, we know we're dealing with a cross-device rename, for
	// which we'll have to simulate atomicity with an intermediate temporary
	// file.

	// Open the staged file. We can't defer its closure because we need to be
	// able to remove it after a successful rename, which we can't do (on some
	// platforms, notably Windows) if the file handle is open.
	stagedFile, err := os.Open(stagedPath)
	if err != nil {
		return errors.Wrap(err, "unable to open staged file")
	}

	// Create a temporary file in the target directory. We can't defer its
	// closure because we'll want to be rename it or remove it on rename
	// failure, which we can't do (on some platforms, notably Windows) if the
	// file handle is open.
	temporaryName, temporary, err := parent.CreateTemporaryFile(crossDeviceRenameTemporaryNamePrefix)
	if err != nil {
		stagedFile.Close()
		return errors.Wrap(err, "unable to create temporary file for cross-device rename")
	}

	// Copy the file contents. We'll handle errors below.
	_, copyErr := io.Copy(temporary, stagedFile)

	// Close out files.
	stagedFile.Close()
	temporary.Close()

	// If there was a copy error, then remove the temporary and abort.
	if copyErr != nil {
		parent.RemoveFile(temporaryName)
		return errors.Wrap(copyErr, "unable to copy file contents")
	}

	// Set permissions on the temporary file.
	if err := parent.SetPermissions(temporaryName, t.defaultOwnership, mode); err != nil {
		parent.RemoveFile(temporaryName)
		return errors.Wrap(err, "unable to set intermediate file permissions")
	}

	// Rename the file.
	if err := filesystem.Rename(parent, temporaryName, parent, name); err != nil {
		parent.RemoveFile(temporaryName)
		return errors.Wrap(err, "unable to relocate intermediate file")
	}

	// Remove the staged file. We don't bother checking for errors because
	// there's not much we can or need to do about them at this point.
	os.Remove(stagedPath)

	// Success.
	return nil
}

// swapFile atomically swaps files at the specified path, enforcing that the
// existing file matches what's expected.
func (t *transitioner) swapFile(path string, oldEntry, newEntry *Entry) error {
	// Walk down to the parent of the target and compute the target's leaf name.
	// If we are successful, defer closure of the parent.
	parent, name, err := t.walkToParentAndComputeLeafName(path, true)
	if err != nil {
		return errors.Wrap(err, "unable to walk to transition root")
	}
	defer parent.Close()

	// Ensure that the existing entry hasn't been modified from what we're
	// expecting.
	if err := t.ensureExpectedFile(parent, name, path, oldEntry); err != nil {
		return errors.Wrap(err, "unable to validate existing file")
	}

	// RACE: There is a race condition here between the file check and the file
	// replacement that we have to live with due to limitations in filesystem
	// APIs. The worst case fallout is replacement of contents that are modified
	// during this window.

	// If both files have the same contents (differing only in executability),
	// then we won't have staged the file, so we just change the permissions on
	// the existing file.
	if bytes.Equal(oldEntry.Digest, newEntry.Digest) {
		// Compute the new file mode based on the new entry's executability. We
		// enforce that default file modes don't have executability bits set, so
		// we don't need to strip them out in the event that executability isn't
		// set.
		mode := t.defaultFilePermissionMode
		if newEntry.Executable {
			mode = markExecutableForReaders(mode)
		}

		// Attempt to change file permissions.
		//
		// TODO: If we were to pass in executability preservation information to
		// the transitioner, we could skip this call on systems where
		// executability information is not preserved.
		if err := parent.SetPermissions(name, t.defaultOwnership, mode); err != nil {
			return errors.Wrap(err, "unable to change file permissions")
		}

		// Success.
		return nil
	}

	// Otherwise, we will have a staged file, so find it and move it into place.
	return t.findAndMoveStagedFileIntoPlace(path, newEntry, parent, name)
}

// createFile creates the target file at the specified path.
func (t *transitioner) createFile(parent *filesystem.Directory, name, path string, target *Entry) error {
	// Ensure that the target path doesn't exist, e.g. due to a case conflict or
	// modification since the last scan.
	if err := t.ensureNotExists(parent, name); err != nil {
		return errors.Wrap(err, "unable to ensure path does not exist")
	}

	// RACE: There is a race condition here between the non-existence check and
	// the file relocation that we have to live with due to limitations in
	// filesystem APIs. The worst case fallout is replacement of contents that
	// are created during this window.

	// Find the staged file and move it into place.
	return t.findAndMoveStagedFileIntoPlace(path, target, parent, name)
}

// createSymbolicLink creates the target symbolic link at the specified path.
func (t *transitioner) createSymbolicLink(parent *filesystem.Directory, name, path string, target *Entry) error {
	// Verify that the symbolic link agrees with our symbolic link handling
	// mode.
	if t.symlinkMode == SymlinkMode_SymlinkModeIgnore {
		return errors.New("symbolic link creation requested with symbolic links ignored")
	} else if t.symlinkMode == SymlinkMode_SymlinkModePortable {
		if normalized, err := normalizeSymlinkAndEnsurePortable(path, target.Target); err != nil || normalized != target.Target {
			return errors.New("symbolic link was not in normalized form or was not portable")
		}
	}

	// Ensure that the target path doesn't exist, e.g. due to a case conflict or
	// modification since the last scan.
	if err := t.ensureNotExists(parent, name); err != nil {
		return errors.Wrap(err, "unable to ensure path does not exist")
	}

	// RACE: There is a race condition here between the non-existence check and
	// the symbolic link creation that we have to live with due to limitations
	// in filesystem APIs. The worst case fallout is replacement of contents
	// that are created during this window.

	// Create the symbolic link.
	return parent.CreateSymbolicLink(name, target.Target)
}

// createDirectory creates the target directory at the specified path. If only a
// portion of the directory can be created, an entry representing that portion
// will be returned.
func (t *transitioner) createDirectory(parent *filesystem.Directory, name, path string, target *Entry) *Entry {
	// Ensure that the target path doesn't exist, e.g. due to a case conflict or
	// modification since the last scan.
	if err := t.ensureNotExists(parent, name); err != nil {
		t.recordProblem(path, errors.Wrap(err, "unable to ensure path does not exist"))
		return nil
	}

	// Attempt to create the directory.
	if err := parent.CreateDirectory(name); err != nil {
		t.recordProblem(path, errors.Wrap(err, "unable to create directory"))
		return nil
	}

	// Create a shallow copy of the target that we'll populate as we create its
	// contents.
	created := target.copySlim()

	// RACE: There is a race condition here between the directory creation and
	// the permission setting and the creation of the directory's contents that
	// we have to live with due to limitations in filesystem APIs. The worst
	// case fallout is that the directory has been replaced by another file on
	// which permissions are set and modifications are made. If this other
	// object is a non-directory, then errors will arise quickly.

	// Set directory permissions. If this fails, we abort the remainder of the
	// operation because it's indicative of the fact that something's wrong.
	// However, since we did succeed in creating the directory, we return that
	// portion.
	if err := parent.SetPermissions(name, t.defaultOwnership, t.defaultDirectoryPermissionMode); err != nil {
		t.recordProblem(path, errors.Wrap(err, "unable to set directory permissions"))
		return created
	}

	// If there are contents in the target, allocate a map for created, because
	// we'll need to populate it, and open the directory for operations
	// (deferring its closure).
	var directory *filesystem.Directory
	if len(target.Contents) > 0 {
		// Allocate the content map.
		created.Contents = make(map[string]*Entry)

		// Open the directory.
		if d, err := parent.OpenDirectory(name); err != nil {
			t.recordProblem(path, errors.Wrap(err, "unable to open new directory"))
			return created
		} else {
			directory = d
			defer directory.Close()
		}
	}

	// Attempt to create the target contents. Track problems as we go.
	for name, entry := range target.Contents {
		// Compute the content path.
		contentPath := pathJoin(path, name)

		// Handle content creation based on type.
		if entry.Kind == EntryKind_Directory {
			if c := t.createDirectory(directory, name, contentPath, entry); c != nil {
				created.Contents[name] = c
			}
		} else if entry.Kind == EntryKind_File {
			if err := t.createFile(directory, name, contentPath, entry); err != nil {
				t.recordProblem(contentPath, errors.Wrap(err, "unable to create file"))
			} else {
				created.Contents[name] = entry
			}
		} else if entry.Kind == EntryKind_Symlink {
			if err := t.createSymbolicLink(directory, name, contentPath, entry); err != nil {
				t.recordProblem(contentPath, errors.Wrap(err, "unable to create symbolic link"))
			} else {
				created.Contents[name] = entry
			}
		} else {
			t.recordProblem(contentPath, errors.New("creation requested for unknown entry type"))
		}
	}

	// Return the portion of the target that was created.
	return created
}

// create creates the target content at the specified path. If only a portion of
// the content can be created, an entry representing that portion will be
// returned.
func (t *transitioner) create(path string, target *Entry) *Entry {
	// If the target is nil, we're done.
	if target == nil {
		return nil
	}

	// Walk down to the parent of the target and compute the target's leaf name.
	// If we are successful, defer closure of the parent.
	parent, name, err := t.walkToParentAndComputeLeafName(path, false)
	if err != nil {
		t.recordProblem(path, errors.Wrap(err, "unable to walk to transition root parent"))
		return nil
	}
	defer parent.Close()

	// Handle creation based on type.
	if target.Kind == EntryKind_Directory {
		return t.createDirectory(parent, name, path, target)
	} else if target.Kind == EntryKind_File {
		if err := t.createFile(parent, name, path, target); err != nil {
			t.recordProblem(path, errors.Wrap(err, "unable to create file"))
			return nil
		} else {
			return target
		}
	} else if target.Kind == EntryKind_Symlink {
		if err := t.createSymbolicLink(parent, name, path, target); err != nil {
			t.recordProblem(path, errors.Wrap(err, "unable to create symlink"))
			return nil
		} else {
			return target
		}
	} else {
		t.recordProblem(path, errors.New("creation requested for unknown entry type"))
		return nil
	}
}

// Transition provides recursive filesystem transitioning facilities for
// synchronization roots, allowing the application of changes after
// reconciliation. The path to the provided synchronization root must be
// absolute and normalized (using filepath.Clean). The function returns a slice
// of the resulting entries, problems, and a boolean indicating whether or not
// the provider was missing files.
func Transition(
	root string,
	transitions []*Change,
	cache *Cache,
	symlinkMode SymlinkMode,
	defaultFilePermissionMode filesystem.Mode,
	defaultDirectoryPermissionMode filesystem.Mode,
	defaultOwnership *filesystem.OwnershipSpecification,
	recomposeUnicode bool,
	provider Provider,
) ([]*Entry, []*Problem, bool) {
	// Create the transitioner.
	transitioner := &transitioner{
		root:                           root,
		cache:                          cache,
		symlinkMode:                    symlinkMode,
		defaultFilePermissionMode:      defaultFilePermissionMode,
		defaultDirectoryPermissionMode: defaultDirectoryPermissionMode,
		defaultOwnership:               defaultOwnership,
		recomposeUnicode:               recomposeUnicode,
		provider:                       provider,
	}

	// Set up results.
	var results []*Entry

	// Iterate through transitions.
	for _, t := range transitions {
		// Handle the special case where both old and new are a file. In this
		// case we can do a simple swap. It makes sense to handle this specially
		// because it is a very common case and doing it with a swap will remove
		// any window where the path is empty on the filesystem.
		fileToFile := t.Old != nil && t.New != nil &&
			t.Old.Kind == EntryKind_File &&
			t.New.Kind == EntryKind_File
		if fileToFile {
			if err := transitioner.swapFile(t.Path, t.Old, t.New); err != nil {
				results = append(results, t.Old)
				transitioner.recordProblem(t.Path, errors.Wrap(err, "unable to swap file"))
			} else {
				results = append(results, t.New)
			}
			continue
		}

		// Reduce whatever we expect to see on disk to nil (remove it). If we
		// don't expect to see anything (t.Old == nil), this is a no-op. If this
		// fails, record the reduced entry and continue to the next transition.
		if r := transitioner.remove(t.Path, t.Old); r != nil {
			results = append(results, r)
			continue
		}

		// At this point, we should have nil on disk. Transition to whatever the
		// new entry is (or at least as much of it as we can create). If the new
		// entry is nil, this is a no-op.
		results = append(results, transitioner.create(t.Path, t.New))
	}

	// Done.
	return results, transitioner.problems, transitioner.providerMissingFiles
}
